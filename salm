#!/usr/bin/env -S nu '--experimental-options=[reorder-cell-paths pipefail enforce-runtime-annotations]'

use std/log

# Reads *.toml recursively and does stuff.
def main [] { }

def 'main list' [
   --config-dir (-c): path = . # full path to config directory
]: nothing -> list {
   build-config $config_dir | columns | sort
}

def 'main show' [
   --config-dir (-c): path = . # full path to config directory
   ...profiles: string # list of profile names
]: nothing -> record {
   if ($profiles | is-empty) {
      error make {msg: "Missing parameter..."}
   }

   let profiles = $profiles | each {|profile| [$profile] | into cell-path }
   let config = build-config $config_dir

   $config | get ($profiles | first) ...($profiles | drop 1)
}

def 'main install' [
   --config-dir (-c): path = . # full path to config directory
   ...profiles: string # list of profile names
]: nothing -> nothing {
   if ($profiles | is-empty) {
      error make {msg: "Missing parameter..."}
   }

   let profiles = $profiles | each {|profile| [$profile] | into cell-path }
   let config = build-config $config_dir
   let config = $config | get ($profiles | first) ...($profiles | drop 1)

   do {
      if $config.files? == null or ($config.files | is-empty) {
         return
      }

      $config.files | each {|file|
         let install_result = install-file $file

         {
            target: $file.target_abs_path
            status: $install_result.status
         }
      } | print
   }

   do {
      if $config.packages? == null or ($config.packages | is-empty) {
         log info "skipping packages management - nothing to do"
         return
      }

      let installed_packages = pacman -Qq | lines

      let missing_packages = $config.packages | where {|package|
         ($package.name not-in $installed_packages) and $package.ignore == false
      }

      if ($missing_packages | is-empty) {
         log info "skipping packages install - already installed"
         return
      }

      log info 'checking packages to install'

      let missing_std_package_names = $missing_packages
      | where from == 'std'
      | each {|missing_package| $missing_package.name }

      do {
         if ($missing_std_package_names | is-empty) {
            return
         }

         try {
            pacman -S ...$missing_std_package_names
         } catch {|error|
            $error.rendered | print
         }
      }

      let missing_aur_package_names = $missing_packages
      | where from == 'aur'
      | each {|missing_aur_package| $missing_aur_package.name }

      do {
         if ($missing_aur_package_names | is-empty) {
            return
         }

         try {
            paru -S --aur ...$missing_aur_package_names
         } catch {|error|
            $error.rendered | print
         }
      }

      let missing_local_package_paths = $missing_packages
      | where from == 'lcl'
      | each {|missing_package| $missing_package.path }

      do {
         if ($missing_local_package_paths | is-empty) {
            return
         }

         try {
            paru -Bi ...$missing_local_package_paths
         } catch {|error|
            $error.rendered | print
         }
      }
   }

   do {
      if $config.units == null or ($config.units | is-empty) {
         return
      }

      $config.units | each {|unit|
         enable-units $unit.user ...$unit.enable | print
      }
   }

   null
}

def 'main cleanup' [
   --config-dir (-c): path = . # full path to config directory
   ...profiles: string # list of profile names
]: nothing -> nothing {
   if ($profiles | is-empty) {
      error make {msg: "Missing parameter..."}
   }

   let profiles = $profiles | each {|profile| [$profile] | into cell-path }
   let config = build-config $config_dir
   let config = $config | get ($profiles | first) ...($profiles | drop 1)

   do {
      if $config.packages? == null or ($config.packages | is-empty) {
         log info "skipping packages management - nothing to do"
         return
      }

      try {
         cleanup-packages $config.packages
      } catch {|error|
         $error.rendered | print
      }
   }

   do {
      if $config.units == null or ($config.units | is-empty) {
         return
      }

      $config.units | each {|unit|
         cleanup-units $unit.user ...$unit.enable | print
      }
   }

   null
}

def install-file [
   file: record
]: nothing -> record<status: string> {
   log info (
      "checking file to install -" +
      $" owner=($file.owner) target=($file.target_abs_path)"
   )

   match $file.action {
      copy => {
         copy-file $file
      }

      link => {
         link-file $file
      }

      _ => {
         log error $"skipped file install - no method - action=($file.action)"
         {status: 'failed'}
      }
   }
}

def copy-file [
   file
]: nothing -> record<status: string> {
   let source_abs_path_type = $file.source_abs_path | path type
   let target_abs_path_type = $file.target_abs_path | path type

   try {
      match [$source_abs_path_type $target_abs_path_type] {
         [null _] => {
            log error (
               $"skipped copy - source does not exist -"
               + $" source=($file.source_abs_path)"
            )

            {status: 'failed'}
         }

         [_ null] => {
            let target_dir_abs_path = $file.target_abs_path | path dirname

            if not ($target_dir_abs_path | path exists) {
               mkdir $target_dir_abs_path
            }

            log info $"copying file - target=($file.target_abs_path)"
            cp -r $file.source_abs_path $file.target_abs_path
            chmod $file.chmod $file.target_abs_path
            chown -R $"($file.owner):($file.group)" $file.target_abs_path
            {status: 'success'}
         }

         [dir dir] => {
            if (
               diff
               -rq
               $file.target_abs_path
               $file.source_abs_path
               | complete
               | get exit_code
               | $in == 0
            ) {
               log info (
                  $"skipping dir copy - target matches - target=($file.target_abs_path)"
               )

               return {status: 'skipped'}
            }

            log info $"copying dir - target=($file.target_abs_path)"
            rm -r $file.target_abs_path
            cp -r $file.source_abs_path $file.target_abs_path
            chmod $file.chmod $file.target_abs_path
            chown -R $"($file.owner):($file.group)" $file.target_abs_path
            {status: 'success'}
         }

         [file file] => {
            let target_file = open --raw $file.target_abs_path
            let source_file = open --raw $file.source_abs_path

            if ($target_file == $source_file) {
               log info (
                  $"skipping file copy - target matches - target=($file.target_abs_path)"
               )

               return {status: 'skipped'}
            }

            log info $"copying file - target=($file.target_abs_path)"
            rm $file.target_abs_path
            cp $file.source_abs_path $file.target_abs_path
            chmod $file.chmod $file.target_abs_path
            chown -R $"($file.owner):($file.group)" $file.target_abs_path
            {status: 'success'}
         }

         [symlink symlink] => {
            if (
               ($file.source_abs_path | path expand) ==
               ($file.target_abs_path | path expand)
            ) {
               log info (
                  $"skipping symlink copy - target matches - target=($file.target_abs_path)"
               )

               return {status: 'skipped'}
            }

            log info $"copying symlink - target=($file.target_abs_path)"
            unlink $file.target_abs_path
            cp $file.source_abs_path $file.target_abs_path
            chmod $file.chmod $file.target_abs_path
            chown -R $"($file.owner):($file.group)" $file.target_abs_path
            {status: 'success'}
         }

         [_ _] => {
            log error (
               $"skipped copying - no method - action=($file.action)" +
               $" source=($file.source_abs_path)" +
               $" target=($file.target_abs_path)"
            )

            {status: 'failed'}
         }
      }
   } catch {
      {status: 'failed'}
   }
}

def link-file [
   file
]: nothing -> record<status: string> {
   let source_abs_path_type = $file.source_abs_path | path type
   let target_abs_path_type = $file.target_abs_path | path type

   try {
      match [$source_abs_path_type $target_abs_path_type] {
         [null _] => {
            (
               log
               error
               $"skipped link - source does not exist - source=($file.source_abs_path)"
            )

            {status: 'failed'}
         }

         [_ null] => {

            let target_parent_dir_abs_path = $file.target_abs_path | path dirname

            if not ($target_parent_dir_abs_path | path exists) {
               mkdir $target_parent_dir_abs_path
            }

            log info $"linking - target=($file.target_abs_path)"
            ln -s $file.source_abs_path $file.target_abs_path
            chown -R $"($file.owner):($file.group)" $file.target_abs_path
            {status: 'success'}
         }

         [_ dir] => {
            log info $"linking - target=($file.target_abs_path)"
            rm -r $file.target_abs_path
            ln -s $file.source_abs_path $file.target_abs_path
            chown -R $"($file.owner):($file.group)" $file.target_abs_path
            {status: 'success'}
         }

         [_ file] => {
            log info $"linking - target=($file.target_abs_path)"
            rm $file.target_abs_path
            ln -s $file.source_abs_path $file.target_abs_path
            chown -R $"($file.owner):($file.group)" $file.target_abs_path
            {status: 'success'}
         }

         [_ symlink] => {
            if (
               ($file.target_abs_path | path expand) ==
               $file.source_abs_path
            ) {
               log info (
                  $"skipping link - target matches - target=($file.target_abs_path)"
               )

               return {status: 'skipped'}
            }

            log info $"linking - target=($file.target_abs_path)"
            unlink $file.target_abs_path
            ln -s $file.source_abs_path $file.target_abs_path
            chown -R $"($file.owner):($file.group)" $file.target_abs_path
            {status: 'success'}
         }

         [_ _] => {
            log error (
               $"skipped link - no method - action=($file.action)" +
               $" source=($file.source_abs_path)" +
               $" target=($file.target_abs_path)"
            )

            {status: 'failed'}
         }
      }
   } catch {
      {status: 'failed'}
   }
}

def cleanup-packages [
   packages
]: nothing -> nothing {
   log info 'checking packages to cleanup'
   let installed_package_names = pacman -Qq | lines
   let package_names = $packages | par-each {|package| $package.name }

   let unlisted_packages_names = $installed_package_names
   | par-each {|installed_package_name|
      if not ($installed_package_name | is-package-a-dependency) {
         if $installed_package_name not-in $package_names {
            $installed_package_name
         }
      }
   }

   if ($unlisted_packages_names | is-not-empty) {
      log info 'cleaning up packages'
      pacman -Rns ...$unlisted_packages_names
   } else {
      log info 'skipping packages cleanup - there is nothing to do'
   }
}

def is-package-a-dependency []: string -> bool {
   let package = $in

   pactree -rl $package
   | complete
   | get stdout
   | lines
   | length
   | $in > 1
}

def cleanup-units [
   user: string
   ...keep_unit_names: string
]: nothing -> table {
   def list-reverse-dependencies [
      --user: string
      unit_name: string
   ]: nothing -> list {
      let dependencies = if $user == null or $user == 'root' {
         systemctl list-dependencies --reverse --plain $unit_name
      } else {
         systemctl -M $"($user)@" --user list-dependencies --reverse --plain $unit_name
      }
      | lines
      | each {|line| $line | str trim }
      | where {|dependency|
         (
            ($dependency | str ends-with '.service') or
            ($dependency | str ends-with '.timer') or
            ($dependency | str ends-with '.socket') or
            ($dependency | str ends-with '.path')
         )
      }
      | skip 1

      $dependencies
   }

   def list-dependencies [
      --user: string
      unit_name: string
   ]: nothing -> list {
      let dependencies = if $user == null or $user == 'root' {
         systemctl list-dependencies --plain $unit_name
      } else {
         systemctl -M $"($user)@" --user list-dependencies --plain $unit_name
      }
      | lines
      | each {|line| $line | str trim }
      | where {|dependency|
         (
            ($dependency | str ends-with '.service') or
            ($dependency | str ends-with '.timer') or
            ($dependency | str ends-with '.socket') or
            ($dependency | str ends-with '.path')
         )
      }
      | skip 1

      $dependencies
   }

   let enabled_unit_shapes = get-enabled-unit-shapes --user=$user

   let unit_disable_results = $enabled_unit_shapes | each {|enabled_unit_shape|
      let keep_unit_dependency_names = $keep_unit_names | each --flatten {|keep_unit_name|
         list-dependencies --user=$user $keep_unit_name
      }

      let unit_reverse_dependency_names = list-reverse-dependencies --user=$user $enabled_unit_shape.unit_file

      if (
         ($enabled_unit_shape.unit_file in $keep_unit_names) or
         ($enabled_unit_shape.unit_file in $keep_unit_dependency_names) or
         ($unit_reverse_dependency_names | any {|unit_reverse_dependancy_name| $unit_reverse_dependancy_name in $keep_unit_names })
      ) {
         return {
            unit: $enabled_unit_shape.unit_file
            status: 'skipped'
         }
      }

      let is_disable_unit_successful = disable-unit --user=$user $enabled_unit_shape.unit_file

      {
         unit: $enabled_unit_shape.unit_file
         status: (if $is_disable_unit_successful { 'success' } else { 'failed' })
      }
   }

   $unit_disable_results
}

def enable-units [
   user: string
   ...unit_names: string
]: nothing -> table {
   let enabled_unit_shapes = get-enabled-unit-shapes --user $user

   let unit_enable_results = $unit_names | each {|unit_name|
      if ($unit_name in $enabled_unit_shapes.unit_file) {
         return {
            unit: $unit_name
            status: 'skipped'
         }
      }

      let is_enable_unit_successful = enable-unit --user=$user $unit_name

      {
         unit: $unit_name
         status: (if $is_enable_unit_successful { 'success' } else { 'failed' })
      }
   }

   $unit_enable_results
}

def enable-unit [
   --user: string
   unit_name: string
]: nothing -> bool {
   try {
      if $user == null or $user == 'root' {
         systemctl enable $unit_name
      } else {
         systemctl -M $"($user)@" --user enable $unit_name
      }

      true
   } catch {
      false
   }
}

def disable-unit [
   --user: string
   unit_name: string
]: nothing -> bool {
   try {
      if $user == null or $user == 'root' {
         systemctl disable $unit_name
      } else {
         systemctl -M $"($user)@" --user disable $unit_name
      }

      true
   } catch {
      false
   }
}

def get-enabled-unit-shapes [
   --user: string
]: nothing -> table {
   def list-unit-files [
      --user: string
   ]: nothing -> table {
      if $user == null or $user == 'root' {
         systemctl list-unit-files --type=service,timer,socket,path --state=enabled --output=json | from json
      } else {
         systemctl -M $"($user)@" --user list-unit-files --type=service,timer,socket,path --state=enabled --output=json | from json
      }
   }

   def list-units [
      --user: string
      ...target: string
   ]: nothing -> table {
      if $user == null or $user == 'root' {
         systemctl list-units ...$target --output=json | from json
      } else {
         systemctl -M $"($user)@" --user list-units ...$target --output=json | from json
      }
   }

   let unit_shape_ones = list-unit-files --user=$user

   let unit_shape_ones = $unit_shape_ones | each --flatten {|unit_shape_one|
      if not ($unit_shape_one.unit_file | str contains '@') {
         return $unit_shape_one
      }

      let unit_shape_twos = list-units --user=$user ($unit_shape_one.unit_file | str replace @ @*)

      $unit_shape_twos | each {|unit_shape_two|
         {
            unit_file: $unit_shape_two.unit
            state: $unit_shape_one.state
            preset: $unit_shape_one.preset
         }
      }
   }

   $unit_shape_ones
}

def build-config [
   config_dir: path
]: nothing -> any {
   let target = $config_dir | path join '*' '**' '*.toml' | into glob

   let config = ls $target
   | get name
   | reduce -f {} {|raw_config_file_rel_path config|
      let raw_config_file_abs_path = $raw_config_file_rel_path | path expand
      let raw_config = open $raw_config_file_abs_path

      let config = do {
         if $raw_config.files? == null {
            return $config
         }

         $raw_config.files
         | reduce -f $config {|raw_file config|
            $raw_file.profiles
            | reduce -f $config {|raw_profile config|
               let files = $config
               | get -o $raw_profile
               | get -o files
               | default []

               let files = $files
               | append {
                  source_abs_path: (
                     $raw_config_file_abs_path
                     | path dirname
                     | path join $raw_file.source
                     | path expand
                  )

                  target_abs_path: $raw_file.target
                  action: $raw_file.action
                  chmod: $raw_file.chmod
                  owner: $raw_file.owner
                  group: $raw_file.group
               }

               $config | upsert ([$raw_profile files] | into cell-path) $files
            }
         }
      }

      let config = do {
         if $raw_config.packages? == null {
            return $config
         }

         $raw_config.packages
         | reduce -f $config {|raw_package config|
            $raw_package.profiles
            | reduce -f $config {|raw_profile config|
               let packages = $config
               | get -o $raw_profile
               | get -o packages
               | default []

               let packages = $packages
               | append (
                  $raw_package.install
                  | each {|package|
                     let path = if $package.path? != null {
                        $raw_config_file_abs_path
                        | path dirname
                        | path join $package.path
                        | path expand
                     }

                     {
                        from: $package.from
                        name: $package.name
                        ignore: ($package.ignore? | default false)
                        path: $path
                     }
                  }
               )

               $config
               | upsert ([$raw_profile packages] | into cell-path) $packages
            }
         }
      }

      let config = do {
         if $raw_config.units? == null {
            return $config
         }

         $raw_config.units
         | reduce -f $config {|raw_unit config|
            $raw_unit.profiles
            | reduce -f $config {|raw_profile config|
               let units = $config
               | get -o $raw_profile
               | get -o units
               | default []

               let units = $units | append {
                  dir_abs_path: $raw_unit.path
                  user: $raw_unit.user
                  mask: $raw_unit.mask?
                  enable: $raw_unit.enable?
               }

               $config | upsert ([$raw_profile units] | into cell-path) $units
            }
         }
      }

      $config
   }

   $config
}
