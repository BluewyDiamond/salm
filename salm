#!/usr/bin/env -S nu '--experimental-options=[reorder-cell-paths pipefail enforce-runtime-annotations]'

use std/log

# Reads *.toml recursively and does stuff.
def main [] { }

def 'main list' [
   --config-dir (-c): path = . # full path to config directory
]: nothing -> list {
   build-config $config_dir | columns | sort
}

def 'main show' [
   --config-dir (-c): path = . # full path to config directory
   ...profiles: string # list of profile names
]: nothing -> record {
   if ($profiles | is-empty) {
      error make {msg: "Missing parameter..."}
   }

   let profiles = $profiles | each {|profile| [$profile] | into cell-path }
   let config = build-config $config_dir

   $config | get ($profiles | first) ...($profiles | drop 1)
}

def 'main install' [
   --config-dir (-c): path = . # full path to config directory
   ...profiles: string # list of profile names
]: nothing -> nothing {
   if ($profiles | is-empty) {
      error make {msg: "Missing parameter..."}
   }

   let profiles = $profiles | each {|profile| [$profile] | into cell-path }
   let config = build-config $config_dir
   let config = $config | get ($profiles | first) ...($profiles | drop 1)

   do {
      if $config.files? == null or ($config.files | is-empty) {
         log info "no files to manage"
         return
      }

      $config.files | each {|file|
         try {
            install-file $file
         } catch {|error|
            $error.rendered | print
         }
      }
   }

   do {
      if $config.packages? == null or ($config.packages | is-empty) {
         log info "no packages to manage"
         return
      }

      let installed_packages = pacman -Qq | lines

      let missing_packages = $config.packages | where {|package|
         ($package.name not-in $installed_packages) and $package.ignore == false
      }

      if ($missing_packages | is-empty) {
         log info $"skipping because there is no packages to install"
         return
      }

      try {
         pacman -S ($missing_packages | where from == 'std')
      } catch {|error|
         $error.rendered | print
      }

      try {
         aura -A ($missing_packages | where from == 'aur')
      } catch {|error|
         $error.rendered | print
      }

      try {
         makepkg -si -D (
            $missing_packages
            | where from == 'aur'
            | each {|missing_package| $missing_package.path }
         )
      } catch {|error|
         $error.rendered | print
      }
   }

   do {
      if $config.units == null or ($config.units | is-empty) {
         log info "no units to manage"
         return
      }

      $config.units | each {|unit|
         let enabled_units = get-enabled-units $unit.dir_abs_path

         if $enabled_units == null {
            log error $"skipping because of lack of permissions for unit_path=($unit.path) owned-by=($unit.user)"
            return null
         }

         try {
            do-unit $unit $enabled_units
         } catch {|error|
            $error.rendered | print
         }
      }
   }

   null
}

def 'main cleanup' [
   --config-dir (-c): path = . # full path to config directory
   ...profiles: string # list of profile names
]: nothing -> nothing {
   if ($profiles | is-empty) {
      error make {msg: "Missing parameter..."}
   }

   let profiles = $profiles | each {|profile| [$profile] | into cell-path }
   let config = build-config $config_dir
   let config = $config | get ($profiles | first) ...($profiles | drop 1)

   do {
      if $config.packages? == null or ($config.packages | is-empty) {
         log info "no packages to manage"
         return
      }

      try {
         cleanup-packages $config.packages
      } catch {|error|
         $error.rendered | print
      }
   }

   do {
      if $config.units == null or ($config.units | is-empty) {
         log info "no units to manage"
         return
      }

      $config.units | each {|unit|
         let enabled_units = get-enabled-units $unit.dir_abs_path

         if $enabled_units == null {
            log error $"skipping because of lack of permissions for unit_path=($unit.path) owned-by=($unit.user)"
            return
         }

         try {
            cleanup-unit $unit $enabled_units
         } catch {|error|
            $error.rendered | print
         }
      }
   }

   null
}

def install-file [
   file: record
]: nothing -> nothing {
   log info (
      $"checking file to install with owner=($file.owner)" +
      $" with target=($file.target_abs_path)"
   )

   match $file.action {
      copy => {
         copy-file $file
      }

      link => {
         link-file $file
      }

      _ => {
         log error $"skipped because not implemeted for action=($file.action)"
      }
   }
}

def copy-file [
   file
]: nothing -> nothing {
   let source_abs_path_type = $file.source_abs_path | path type
   let target_abs_path_type = $file.target_abs_path | path type

   match [$source_abs_path_type $target_abs_path_type] {
      [null _] => {
         log error (
            $"skipping because of non-existance for"
            + $" source=($file.source_abs_path)"
         )
      }

      [_ null] => {
         let target_dir_abs_path = $file.target_abs_path | path dirname

         if not ($target_dir_abs_path | path exists) {
            mkdir $target_dir_abs_path
         }

         log info $"installing to target=($file.target_abs_path)"
         cp -r $file.source_abs_path $file.target_abs_path
         chmod $file.chmod $file.target_abs_path
         chown -R $"($file.owner):($file.group)" $file.target_abs_path
      }

      [dir dir] => {
         if (
            diff
            -rq
            $file.target_abs_path
            $file.source_abs_path
            | complete
            | get exit_code
            | $in == 0
         ) {
            log info (
               $"skipping because a match was found for target=($file.target_abs_path)"
            )

            return
         }

         log info $"installing to target=($file.target_abs_path)"
         rm -r $file.target_abs_path
         cp -r $file.source_abs_path $file.target_abs_path
         chmod $file.chmod $file.target_abs_path
         chown -R $"($file.owner):($file.group)" $file.target_abs_path
      }

      [file file] => {
         let target_file = open --raw $file.target_abs_path
         let source_file = open --raw $file.source_abs_path

         if ($target_file == $source_file) {
            log info (
               $"skipping because a match was found for target=($file.target_abs_path)"
            )

            return
         }

         log info $"installing to target=($file.target_abs_path)"
         rm $file.target_abs_path
         cp $file.source_abs_path $file.target_abs_path
         chmod $file.chmod $file.target_abs_path
         chown -R $"($file.owner):($file.group)" $file.target_abs_path
      }

      [symlink symlink] => {
         if (
            ($file.source_abs_path | path expand) ==
            ($file.target_abs_path | path expand)
         ) {
            log info (
               $"skipping because a match was found for target=($file.target_abs_path)"
            )

            return
         }

         log info $"installing to target=($file.target_abs_path)"
         unlink $file.target_abs_path
         cp $file.source_abs_path $file.target_abs_path
         chmod $file.chmod $file.target_abs_path
         chown -R $"($file.owner):($file.group)" $file.target_abs_path
      }

      [_ _] => {
         log error (
            $"skipped because not implemented for action=($file.action)" +
            $" source=($file.source_abs_path)" +
            $" target=($file.target_abs_path)"
         )
      }
   }
}

def link-file [
   file
]: nothing -> nothing {
   let source_abs_path_type = $file.source_abs_path | path type
   let target_abs_path_type = $file.target_abs_path | path type

   match [$source_abs_path_type $target_abs_path_type] {
      [null _] => {
         (
            log
            error
            $"skipping because of non-existance for source=($file.source_abs_path)"
         )
      }

      [_ null] => {

         let target_parent_dir_abs_path = $file.target_abs_path | path dirname

         if not ($target_parent_dir_abs_path | path exists) {
            mkdir $target_parent_dir_abs_path
         }

         log info $"installing to target=($file.target_abs_path)"
         ln -s $file.source_abs_path $file.target_abs_path
         chown -R $"($file.owner):($file.group)" $file.target_abs_path
      }

      [_ dir] => {
         log info $"installing to target=($file.target_abs_path)"
         rm -r $file.target_abs_path
         ln -s $file.source_abs_path $file.target_abs_path
         chown -R $"($file.owner):($file.group)" $file.target_abs_path
      }

      [_ file] => {
         log info $"installing to target=($file.target_abs_path)"
         rm $file.target_abs_path
         ln -s $file.source_abs_path $file.target_abs_path
         chown -R $"($file.owner):($file.group)" $file.target_abs_path
      }

      [_ symlink] => {
         if (
            ($file.target_abs_path | path expand) ==
            $file.source_abs_path
         ) {
            log info (
               $"skipping because a match was found for target=($file.target_abs_path)"
            )

            return
         }

         log info $"installing to target=($file.target_abs_path)"
         unlink $file.target_abs_path
         ln -s $file.source_abs_path $file.target_abs_path
         chown -R $"($file.owner):($file.group)" $file.target_abs_path
      }

      [_ _] => {
         log error (
            $"skipped because not implemented for action=($file.action)" +
            $" source=($file.source_abs_path)" +
            $" target=($file.target_abs_path)"
         )
      }
   }
}

def install-packages [
   packages
   installed_packages: list<string>
   label: string
   on_install: closure
]: nothing -> nothing {
   log info $"checking ($label) packages to install"

   let missing_packages = $packages | where {|package|
      $package.name not-in $installed_packages
   }

   if ($missing_packages | is-empty) {
      log info $"skipping because there is no packages to install for ($label)"
      return
   }

   log info $"installing packages for ($label)"
   do $on_install $missing_packages
}

def cleanup-packages [
   packages
]: nothing -> nothing {
   log info 'checking packages to cleanup'
   let installed_package_names = pacman -Qq | lines
   let package_names = $packages | par-each {|package| $package.name }

   let unlisted_packages_names = $installed_package_names
   | par-each {|installed_package_name|
      if not ($installed_package_name | is-package-a-dependency) {
         if $installed_package_name not-in $package_names {
            $installed_package_name
         }
      }
   }

   if ($unlisted_packages_names | is-not-empty) {
      log info 'cleaning up packages'
      pacman -Rns ...$unlisted_packages_names
   } else {
      log info 'skipping because there is no packages to cleanup'
   }
}

def is-package-a-dependency []: string -> bool {
   let package = $in
   let pactree_output_complete = pactree -rl $package | complete

   if ($pactree_output_complete | get exit_code | $in != 0) {
      return false
   }

   $pactree_output_complete | get stdout | lines | length | $in > 1
}

def do-unit [
   unit
   enabled_unit_names
]: nothing -> nothing {
   log info (
      $"checking services with user=($unit.user)"
      + $" and dir_abs_path=($unit.dir_abs_path)"
   )

   let unit_names_to_enable = $unit.enable | where {|unit_name|
      $unit_name not-in $enabled_unit_names
   }

   if ($unit_names_to_enable | is-empty) {
      log info $"skipping because the units are already enabled"
      return
   }

   $unit_names_to_enable | each {|unit_name_to_enable|
      log info $"enabling service=($unit_name_to_enable) with user=($unit.user)"

      if (is-admin) and ($unit.user == root) {
         systemctl enable $unit_name_to_enable
      } else if (is-admin) {
         systemctl --user -M $"($unit.user)@" enable $unit_name_to_enable
      } else if ($unit.user == $env.LOGNAME) {
         systemctl --user enable $unit_name_to_enable
      } else {
         log error (
            $"skipped because there is no method for"
            + $" unit=($unit_name_to_enable) owned-by=($unit.user)"
         )
      }
   }

   # TODO: Mask units
}

def cleanup-unit [
   unit
   enabled_unit_names
]: nothing -> nothing {
   log info $"checking units with user=($unit.user) and dir_abs_path=($unit.dir_abs_path)"

   let unit_names_to_ignore = $unit.enable
   | each --flatten {|unit_name_to_enable|
      if (is-admin) and ($unit.user == root) {
         systemctl list-dependencies --plain --no-pager $unit_name_to_enable
         | lines
         | str trim
      } else if (is-admin) {
         systemctl --user -M $"($unit.user)@" list-dependencies --plain --no-pager $unit_name_to_enable
         | lines
         | str trim
      } else if ($unit.user == $env.LOGNAME) {
         systemctl --user list-dependencies --plain --no-pager $unit_name_to_enable
         | lines
         | str trim
      } else {
         log error (
            $"throwing error because there is no method for"
            + $" unit=($unit_name_to_enable) owned-by=($unit.user)"
         )
      }
   }
   | uniq

   let unit_names_to_disable = $enabled_unit_names | where {|enabled_unit_name|
      (
         ($enabled_unit_name not-in $unit.enable) and
         ($enabled_unit_name not-in $unit_names_to_ignore)
      )
   }

   if ($unit_names_to_disable | is-empty) {
      log info $"skipping because there is no units to cleanup"
      return
   }

   $unit_names_to_disable | each {|unit_name_to_disable|
      log info $"attempting to disable unit=($unit_name_to_disable) with user=($unit.user)"

      if (is-admin) and ($unit.user == root) {
         systemctl disable $unit_name_to_disable
      } else if (is-admin) {
         systemctl --user -M $"($unit.user)@" disable $unit_name_to_disable
      } else if ($unit.user == $env.LOGNAME) {
         systemctl --user disable $unit_name_to_disable
      } else {
         log error (
            $"skipped because there is no method for"
            + $" unit=($unit_name_to_disable) owned-by=($unit.user)"
         )
      }
   }
}

def get-enabled-units [service_dir_abs_path: string] {
   let g = $"($service_dir_abs_path)/*.wants/*"

   try {
      ls ($g | into glob) | get name | each {|item|
         $item | path basename
      }
   } catch {|$error|
      if (check-what-error $error ["Permission denied"]) {
         return null
      } else if (check-what-error $error ["Pattern, file or folder not found"]) {
         return []
      } else {
         error make $error
      }
   }
}

def build-config [config_dir: path]: nothing -> any {
   let target = $config_dir | path join '*' '**' '*.toml' | into glob

   let config = ls $target
   | get name
   | reduce -f {} {|raw_config_file_rel_path config|
      let raw_config_file_abs_path = $raw_config_file_rel_path | path expand
      let raw_config = open $raw_config_file_abs_path

      let config = do {
         if $raw_config.files? == null {
            return $config
         }

         $raw_config.files
         | reduce -f $config {|raw_file config|
            $raw_file.profiles
            | reduce -f $config {|raw_profile config|
               let files = $config
               | get -o $raw_profile
               | get -o files
               | default []

               let files = $files
               | append {
                  source_abs_path: (
                     $raw_config_file_abs_path
                     | path dirname
                     | path join $raw_file.source
                     | path expand
                  )

                  target_abs_path: $raw_file.target
                  action: $raw_file.action
                  chmod: $raw_file.chmod
                  owner: $raw_file.owner
                  group: $raw_file.group
               }

               $config | upsert ([$raw_profile files] | into cell-path) $files
            }
         }
      }

      let config = do {
         if $raw_config.packages? == null {
            return $config
         }

         $raw_config.packages
         | reduce -f $config {|raw_package config|
            $raw_package.profiles
            | reduce -f $config {|raw_profile config|
               let packages = $config
               | get -o $raw_profile
               | get -o packages
               | default []

               let packages = $packages
               | append (
                  $raw_package.install
                  | each {|package|
                     let path = if $package.path? != null {
                        $raw_config_file_abs_path
                        | path dirname
                        | path join $package.path
                        | path expand
                     }

                     {
                        from: $package.from
                        name: $package.name
                        ignore: ($package.ignore? | default false)
                        path: $path
                     }
                  }
               )

               $config
               | upsert ([$raw_profile packages] | into cell-path) $packages
            }
         }
      }

      let config = do {
         if $raw_config.units? == null {
            return $config
         }

         $raw_config.units
         | reduce -f $config {|raw_unit config|
            $raw_unit.profiles
            | reduce -f $config {|raw_profile config|
               let units = $config
               | get -o $raw_profile
               | get -o units
               | default []

               let units = $units | append {
                  dir_abs_path: $raw_unit.path
                  user: $raw_unit.user
                  mask: $raw_unit.mask?
                  enable: $raw_unit.enable?
               }

               $config | upsert ([$raw_profile units] | into cell-path) $units
            }
         }
      }

      $config
   }

   $config
}
